# GUDID Chronicles — WOW Supply Chain Analytics  
**Technical Specification**

**Version:** 1.0  
**Target Audience:** Systems Architects, AI Engineers, Frontend Developers, Regulatory/Compliance Officers  
**Technology Stack:** Streamlit (Python), Hugging Face Space, OpenAI API, Gemini API, Anthropic API, Grok (xAI), PyVis, Plotly, Pandas, YAML

---

## 1. Overview

### 1.1 Purpose

This document defines the technical design of the **GUDID Chronicles — WOW Supply Chain Analytics** platform implemented in `app.py` with supporting configuration in `agents.yaml` and `SKILL.md`.

The system provides:

- Interactive **supply chain analytics** for medical device packing lists
- A multi-agent **Hybrid Intelligence** layer orchestrating different LLMs
- A **WOW UI** supporting themes, painter-based visual styles, and bilingual UX
- A **Supply Chain Graph** that visualizes supplier–device–customer relations with rich interaction
- Simple **usage logging**, **LLM diagnostics**, and CSV export for compliance/reporting

The primary business domain is **medical device distribution** under UDI/lot/license constraints, with emphasis on traceability, anomaly detection, recall readiness, and regulatory documentation.

### 1.2 Scope

This specification covers:

- Application architecture (UI, orchestration layer, analytics pipeline)
- Data model and ingestion from CSV
- Agent architecture (31 agents from `agents.yaml`, described by `SKILL.md`)
- Multi-LLM integration and configuration
- Visualization subsystems (charts + network graph)
- Usage logging, error handling, security, and deploy/runtime behaviour on Hugging Face Spaces

Non-goals:

- It does **not** specify production-grade SLA, multi-tenant auth, or persistent database design.
- It does **not** attempt to provide medical, clinical, or legal advice; outputs are analysis aids only.

---

## 2. System Architecture

### 2.1 High-Level Components

1. **Streamlit Frontend (app.py)**
   - Renders WOW UI (theming, language, painter styles)
   - Hosts core functional tabs:
     - Chat Interface
     - Agent Catalog
     - Analytics Dashboard (including Usage Log)
     - Agent Headquarters (advanced agent control)
     - Documentation
   - Manages session state (messages, agent orchestrator, usage logs, theme/lang settings).

2. **Agent Layer (`Agent` & `AgentOrchestrator` classes)**
   - Loads agent definitions from `agents.yaml`
   - Wraps LLM calls across multiple providers (OpenAI, Gemini, Anthropic, Grok)
   - Implements simple rule-based query routing when agent is “auto”
   - Logs each agent execution in `conversation_history` and `usage_log`.

3. **Analytics Layer (within app.py)**
   - CSV ingestion + cleaning (`load_packing_list`)
   - Time-series and distribution analysis using Pandas and Plotly
   - Supply chain network construction using networkx + PyVis
   - CSV export of summary tables.

4. **Documentation & Skills Layer**
   - `SKILL.md` describes semantic roles, I/O expectations, and playbooks for all agents.
   - Docs tab surfaces high-level overview and optionally SKILL.md content to UI users.

5. **Execution Environment**
   - Deployed on **Hugging Face Spaces** as a Streamlit app.
   - Uses environment variables for API keys, but allows run-time override in UI if env not set.
   - No external database; all state is per-session in `st.session_state`.

### 2.2 Data Flow Overview

1. User uploads a CSV or uses the built-in sample.
2. App parses, cleans, and enriches data into a Pandas DataFrame.
3. User applies filters (customer, date range, license/lot for graph).
4. Analytics submodule computes:
   - Summary tables (global, by customer, by device/model)
   - Distribution visualizations (time series, customer volume, device volume, license pie)
   - Supply chain network (filtered by LicenseID/Lot, node/edge caps, search term).
5. In parallel, user may:
   - Use **Chat Tab** with auto-routed agent or chosen agent
   - Use **Agent Headquarters** with full control (model, max_tokens, prompt override, chaining)
6. Agent outputs and UI actions are logged to `usage_log` for inspection.

---

## 3. Data Model & Ingestion

### 3.1 Core Data Model

Input data is a denormalized packing list, one row per line item:

```python
Suppliername: str
deliverdate: str        # Excel serial or ISO date-like string
customer: str
licenseID: str
DeviceCategory: str
UDI: str
DeviceName: str
LotNumber: str
SN: str
ModelNum: str
Numbers: str            # Numeric quantity as string
Unit: str               # e.g. "組", "Box", "Set"
3.2 Ingestion (load_packing_list)
Source:
File upload from user (st.file_uploader)
Built-in SAMPLE_CSV (used when no upload is provided)
Steps:
Decode & sanitize
Read file as UTF-8.
Replace full-width Chinese quotes “/” which can break CSV parsing.
Parse
Use pandas.read_csv into a DataFrame.
Date enrichment
Convert deliverdate Excel serial to real datetime via excel_serial_to_date.
Store as deliverdate_dt (Pandas Timestamp).
Quantity normalization
Convert Numbers to integer (coerce errors to 0).
Column presence is not strictly assumed; code guards against missing columns.
3.3 Filtering Semantics
Filters are applied to the DataFrame before computations:

Customer Filter

Multiselect customer values from the dataset.
Mask: rows where customer is in selected set.
Date Range Filter

Slider uses Python datetime.date to avoid type issues across Streamlit versions.
Only applied to non-NaT deliverdate_dt.
Mask: deliverdate_dt.date lies within [start_date, end_date] inclusive.
For graph-specific filters:

LicenseID

Dropdown with ["All"] + unique licenseID.
If not “All”, restrict graph nodes/edges to rows matching the selected licenseID.
LotNumber

Same pattern as LicenseID for LotNumber.
4. Analytical Subsystems
4.1 Summary Tables
Rendered in the Analytics → Supply Chain Analytics tab.

Global Summary Table

1-row overview:
Total Lines
Total Units (sum of Numbers)
Unique Suppliers, Customers, Devices, Models, Lots
Exportable as summary_overview.csv.
Customer Summary Table

Group by customer:
Total_Units (sum Numbers or count if Numbers missing)
Lines (row count)
Unique_Models (distinct ModelNum)
Sorted descending by Total_Units.
Exportable as customer_summary.csv.
Device/Model Summary Table

Group by (DeviceName, ModelNum):
Total_Units
Customers (distinct customer)
Lots (distinct LotNumber)
Sorted by Total_Units.
Exportable as device_model_summary.csv.
All exports use UTF-8 with BOM to be Excel-friendly.

4.2 Distribution Visualizations
Using Plotly Express:

Deliveries Over Time

Group by deliverdate_dt.
Total_Units and Lines.
Line chart (with markers) of Total_Units vs time.
Volume by Customer

Group by customer:
Bar chart: customer vs Total_Units.
Top Devices by Volume

Group by DeviceName, aggregate Total_Units.
Take top 10 by volume.
Bar chart: DeviceName vs Total_Units.
Share by LicenseID (Pie)

Group by licenseID:
Pie chart with segment sizes by Total_Units.
Supply Chain Relation Graph

Described in detail in Section 5.
Provides structural (topological) view complementing numeric charts.
All charts are recomputed over df_f, the filtered subset.

5. Supply Chain Graph Subsystem
5.1 Graph Construction
Implemented via build_supply_chain_graph:

Underlying graph: networkx.DiGraph.
For each filtered row:
Create nodes:
Suppliername (type="supplier")
DeviceName (type="device")
customer (type="customer")
Create edges:
Suppliername → DeviceName
DeviceName → customer
weight attribute on edges uses Numbers (units).
Filters
licenseID filter:
If provided, only include rows where licenseID == selected_license.
LotNumber filter:
If provided, only include rows where LotNumber == selected_lot.
Limits
To avoid rendering overload:

max_nodes (default 200):
If number of distinct nodes would exceed, new nodes are skipped.
max_edges (default 400):
Stops adding edges once this cap is reached.
These caps are user-configurable via numeric inputs in the UI.

5.2 Node Highlight & Search
search_term (string) is optional.
For any node (supplier, device, customer), if the node name contains search_term (case-insensitive), mark:
highlight=True attribute in networkx.
In PyVis:
Highlighted nodes get:
Color: yellow background, orange border
Larger size (e.g. 28 vs 18)
This provides a simple “focus on node” feature for customers or device names.
5.3 Node Styling & Legend
Nodes are styled by type:

Supplier:
Blue (#38bdf8)
Device:
Green (#22c55e)
Customer:
Orange (#f97316)
Highlight:
Yellow (#facc15) with orange border.
The UI renders a static HTML legend indicating:

Supplier (blue)
Device (green)
Customer (orange)
Search highlight (yellow)
5.4 Rendering & Integration
The function render_supply_chain_graph:

Configures PyVis options:
Node size, font size, arrows to destination, basic physics.
Generates HTML via:
net.generate_html(notebook=False)
Fallback: net.write_html(..., notebook=False) and read-back.
Embeds HTML into Streamlit via components.html.
This approach avoids calling net.show() which relies on notebook/local browser contexts that are not available in Hugging Face Spaces.

Graph height is user-configurable (slider 300–900 px).

5.5 Logging
Each graph build logs an event:

type=graph_build
detail="nodes=X, edges=Y, license=..., lot=..., search=..., max_nodes=..., max_edges=..."
into st.session_state.usage_log.

6. Agent Architecture
6.1 Agent Definition (agents.yaml)
Each agent is defined with:

description (Traditional Chinese)
llm_provider: "openai", "gemini", "anthropic", "grok"
model: default model name (e.g. gpt-4o-mini, gemini-2.5-flash)
capabilities: list of human-readable bullet points
system_prompt: carefully crafted role instructions in Traditional Chinese
SKILL.md explains semantic responsibilities, expected input/output, and recommended chaining for all 31 agents.

6.2 Execution Model
AgentOrchestrator:

Loads YAML at startup and instantiates Agent objects.
Provides:
route_query(user_query: str) -> agent_name:
Keyword-based routing when UI selection is auto.
process_query(...):
Chooses agent (auto or explicit)
Calls agent.execute with overrides
Logs conversation_history and usage_log.
Agent.execute:

Accepts:
query: str
Optional system_prompt_override: str
Optional model_override: str
max_tokens: int (default 12000)
Determines effective provider:
Base llm_provider from YAML
Overridden if model_override exists in MODEL_PROVIDER_MAP
Dispatches to _execute_openai / _execute_gemini / _execute_anthropic / _execute_grok.
6.3 Multi-Provider Integration
OpenAI

Uses environment variable OPENAI_API_KEY.
Prefers new Chat Completions API (client.chat.completions.create).
Fallbacks to legacy Completion.create if necessary.
Gemini

Uses google-generativeai library.
API key: GEMINI_API_KEY.
Instantiates GenerativeModel(model) and calls generate_content.
Supports max_output_tokens.
Anthropic

Uses anthropic Python SDK.
API key: ANTHROPIC_API_KEY.
Uses client.messages.create.
Grok (xAI)

Uses requests against https://api.x.ai/v1/chat/completions.
API key: GROK_API_KEY.
Manually builds JSON payload and parses response.
6.4 Agent Headquarters
The Agent HQ tab exposes advanced control:

Select any agent (agents.yaml key).
Select model from the consolidated model list (OpenAI / Gemini / Anthropic / Grok).
Set max_tokens (128–120000).
Optionally override system prompt per run.
Provide arbitrary input text (user narrative, data summary).
Run and view output in markdown or plain text.
Edit output and “Use as next agent input” to support manual chaining.
No hidden conversation history is maintained at the agent level; each run is a stateless single call, but the UI enables user-driven chaining.

7. UI & UX Specification
7.1 Layout
Global Layout

Single-page Streamlit layout with:
Sidebar (settings, agent select, status)
Main content area with tabs
Tabs

Chat

Chat bubbles with user + assistant roles
Optional caption: selected agent + model used
Agents

Expanders per agent:
Description
Provider, default model
Capabilities list
System prompt (code block)
Analytics

Subtabs:
Agent usage stats
Supply chain analytics
Usage log
Agent HQ

Full agent/model/prompt control and chaining.
Docs

Platform description
(Optional) SKILL.md content
7.2 WOW UI
Theme: Light/Dark (radio)
Language: Traditional Chinese / English (radio)
tr(key) handles UI translation.
Painter Styles:
20 predefined style objects with:
Id, localized names
Accent color, background gradients (light/dark)
Text color
Selection:
Jackslot: sequential cycling
Lucky Wheel: random choice
Applied globally via injected CSS (apply_wow_theme).
7.3 API Key Handling
Sidebar “API Keys” expander:

For each provider:
If env var present: display “Loaded from environment” (no input field).
If missing: password text input for key; sets os.environ for runtime only.
Save keys button clarifies keys are not persisted to disk.
7.4 Usage Logging
usage_log (session-scoped list of dicts):

Event types:
"csv_upload" with filename
"csv_sample_used" when fallback dataset is used
"graph_build" with node/edge/filter details
"agent_run" with agent and model
"chat_cleared" when conversation reset
Exposed in Analytics → Usage Log subtab as a sortable DataFrame.
8. Error Handling & Robustness
CSV parsing:
Handles full-width quotes.
Tolerates missing columns.
Date slider:
Uses only datetime.date to avoid type mismatch errors in Streamlit.
Ignores NaT rows when calculating min/max.
Graph construction:
Bounded by max_nodes / max_edges.
Skips rows with no valid nodes.
PyVis rendering:
Avoids net.show.
Uses generate_html or write_html(..., notebook=False) fallback.
LLM calls:
Check for missing API keys and missing client libraries, returning human-readable messages instead of exceptions.
9. Deployment & Runtime Considerations
9.1 Hugging Face Space
requirements.txt includes:
streamlit, pandas, numpy, pyyaml
openai, anthropic, google-generativeai
plotly, networkx, pyvis, requests
app.py is executed directly in HF Space environment.
No persistent volume is required; logs and state are purely in memory per session.
9.2 Security & Compliance
API keys:
Preferred via environment variables (HF secrets).
Optional in-UI entry for development/POC; not persisted.
Data:
CSV data remains in memory of current session only.
No external database or disk persistence of sensitive data.
LLM Calls:
Data passed to third-party APIs; for regulated/production use, must be evaluated under applicable PHI/PII and data residency requirements.
10. Extensibility
10.1 Agents
New agents can be added by editing agents.yaml and updating SKILL.md.
No code change required if:
llm_provider is one of the supported providers.
model is valid for that provider.
10.2 Visualizations
New charts can be added in render_supply_chain_analytics:
Additional groupby patterns (e.g., DeviceCategory).
Additional cross-filter interactions (future enhancement).
10.3 External Integration
The separation between:
Agent layer (pure Python service wrapper)
UI layer (Streamlit)
makes it feasible to extract the orchestration into a REST API or integrate into a React SPA in the future.
11. Assumptions & Limitations
Dataset sizes are moderate (e.g., up to tens of thousands of rows); no explicit big data optimizations.
All interactions are single-user, single-session; there is no multi-user state sharing.
All agent prompts and SKILL docs are in Traditional Chinese by default; English usage is possible but not the main target language.
Network graph layout and performance depend on browser & device capabilities; large graphs may still be heavy despite node/edge caps.
